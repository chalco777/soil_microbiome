---
title: "differential_COG_GO_KEGG"
output: html_document
date: "2024-11-15"
---
```{r setup, include=FALSE}
library(knitr)
knitr::opts_knit$set(root.dir = "C:/Users/DAVID 21/OneDrive/Documentos/Mirkoslab/alen-belem/eggnog_abundance_new/results_differential_2.0")
```

```{r}
library(tidyverse)
library(Maaslin2)
library(KEGGREST)
library(httr)
library(jsonlite)
library(rvest)
library(ggpubr)

setwd("C:/Users/DAVID 21/OneDrive/Documentos/Mirkoslab/alen-belem/eggnog_abundance_new")
cog_categories <- c(
  "A" = "RNA processing and modification",
  "B" = "Chromatin structure and dynamics",
  "C" = "Energy production and conversion",
  "D" = "Cell cycle control, cell division,\nchromosome partitioning",
  "E" = "Amino acid transport and metabolism",
  "F" = "Nucleotide transport and metabolism",
  "G" = "Carbohydrate transport and metabolism",
  "H" = "Coenzyme transport and metabolism",
  "I" = "Lipid transport and metabolism",
  "J" = "Translation, ribosomal structure and biogenesis",
  "K" = "Transcription",
  "L" = "Replication, recombination and repair",
  "M" = "Cell wall/membrane/envelope biogenesis",
  "N" = "Cell motility",
  "O" = "Posttranslational modification, protein turnover,\nchaperones",
  "P" = "Inorganic ion transport and metabolism",
  "Q" = "Secondary metabolites biosynthesis, transport\nand catabolism",
  "R" = "General function prediction only",
  "S" = "Function unknown",
  "T" = "Signal transduction mechanisms",
  "U" = "Intracellular trafficking, secretion, and\nvesicular transport",
  "V" = "Defense mechanisms",
  "W" = "Extracellular structures",
  "Y" = "Nuclear structure",
  "Z" = "Cytoskeleton", "EU" = "Amino acid transport and metabolism+\nIntracellular trafficking, secretion, and vesicular transport",
  "KT" = "Transcription+Signal transduction mechanisms",
  "NT" = "Cell motility+Signal transduction mechanisms",
  "CG" = "Energy production and conversion+\nCarbohydrate transport and metabolism",
  "HL" = "Coenzyme transport and metabolism+\nReplication, recombination and repair",
  "IT" = "Lipid transport and metabolism+\nSignal transduction mechanisms",
  "EGP" = "Amino acid + Carbohydrate + Inorganic ion\ntransport and metabolism",
  "MT" = "Cell wall/membrane/envelope biogenesis+\nSignal transduction mechanisms",
  "CEH" = "Energy production and conversion+Amino acid+ \nCoenzyme transport and metabolism",
  "GK" = "Carbohydrate transport and metabolism+Transcription",
  "KP" = "Transcription+Inorganic ion transport and metabolism",
  "IM" = "Lipid transport and metabolism+\nCell wall/membrane/envelope biogenesis",
  "CJ" = "Energy production and conversion+\nTranslation, ribosomal structure and biogenesis",
  "MU" = "Cell wall/membrane/envelope biogenesis+\nIntracellular trafficking, secretion, and vesicular transport",
  "FH" = "Nucleotide transport and metabolism+\nCoenzyme transport and metabolism",
  "CO" = "Energy production and conversion+\nPosttranslational modification, protein turnover, chaperones",
  "EH" = "Amino acid transport and metabolism+\nCoenzyme transport and metabolism",
  "KNT" = "Transcription+Cell motility+\nSignal transduction mechanisms",
  "KLT" = "Transcription+Replication, recombination and repair+\nSignal transduction mechanisms",
  "JM" = "Translation, ribosomal structure and biogenesis+\nCell wall/membrane/envelope biogenesis",
  "EK" = "Amino acid transport and metabolism+Transcription",
  "CI" = "Energy production and conversion+\nLipid transport and metabolism",
  "IK" = "Lipid transport and metabolism+Transcription",
  "JKL" = "Translation, ribosomal structure and biogenesis+\nTranscription+Lipid transport and metabolism",
  "HJ" = "Coenzyme transport and metabolism+\nTranslation, ribosomal structure and biogenesis",
  "EJ" = "Amino acid transport and metabolism+\nTranslation, ribosomal structure and biogenesis",
  "KQ" = "Transcription+Secondary metabolites biosynthesis,\ntransport and catabolism",
  "HK" = "Coenzyme transport and metabolism+Transcription",
  "PQ" = "Inorganic ion transport and metabolism+\nSecondary metabolites biosynthesis, transport and catabolism",
  "CQ" = "Energy production and conversion+\nSecondary metabolites biosynthesis, transport and catabolism",
  "ET" = "Amino acid transport and metabolism+\nSignal transduction mechanisms",
  "GM" = "Carbohydrate transport and metabolism+\nCell wall/membrane/envelope biogenesis",
  "UW" = "Intracellular trafficking, secretion, and vesicular transport+\nExtracellular structures",
  "FP" = "Nucleotide transport and metabolism+\nInorganic ion transport and metabolism",
  "GT" = "Carbohydrate transport and metabolism+\nSignal transduction mechanisms")
df<-read_tsv("combined_gff_final_corrected.tsv",col_names = c("sample","contig","program","type","start","end",                 "score","strand","phase","attributes","mge")) %>% filter(!sample%in%c("barcode03",paste0("barcode",30:33))) 

libra<-read_table("wcline.tsv",col_names = c("size","sample")) %>%
  mutate(sample=gsub("^./(.*)/.*fastq","\\1",sample)) %>% mutate(size=as.numeric(size)) %>% filter(!sample%in%c("barcode03",paste0("barcode",30:33))) %>% mutate(size=size/4)
```
#OBTENIENDO TABLAS PRINCIPALES
```{r}
df_main<-df %>%
  # Separa primero lo básico en ID, name, locus_tag, product, rest
  separate(attributes,
           into = c("ID", "name","locus_tag","product","rest"),
           sep = ";",
           extra = "merge") %>% 
  mutate(
    cog    = str_extract(rest, "(?<=em_COG_cat=)[^;]+"),
    GO       = str_extract(rest, "GOs=[^;]+"),
    pathways = str_extract(rest, "KEGG_Pathway=[^;]+"),
    brite    = str_extract(rest, "BRITE=[^;]+"),
    pfams    = str_extract(rest, "PFAMs=[^;]+"),
    conteo   = str_extract(rest, "CONTEO=[^;]+")
  ) %>% 
    mutate(across(c(17:21, 10:13), ~ str_remove(., ".*="))) %>% 
    select(-"rest")
df_main<-df_main %>%filter(!(sample %in% c(paste0("barcode",30:33),"barcode07","barcode11","barcode13","barcode14","barcode18",paste0("barcode",20:22)))) %>% 
  mutate(status = case_when(
    sample %in% c('barcode01', 'barcode02', 'barcode03', 'barcode04', 'barcode05','barcode06') ~ 'barcode30',
    sample %in% c('barcode08', 'barcode09', 'barcode10', 'barcode12') ~ 'barcode32'  ,
    TRUE ~ 'barcode33'
  ))%>% filter(!is.na(conteo))
df_main<-df_main%>% 
  mutate(conteo = replace_na(conteo, "0")) %>% 
  mutate(across(
    c(15:19), 
    ~ replace_na(.x, "Not_assigned")),
    cog = str_replace(cog, "None", "Not_assigned")
  ) %>% mutate(conteo=as.numeric(conteo))
df_main$status <- factor(df_main$status, levels = c("barcode30", "barcode32", "barcode33"))
```

#COG ANALYSIS:MAASLIND AND BOXPLOTS
###PLASMIDO CONTEO CRUDO
```{r}
cat_plasmid<-df_main %>% 
    filter(str_detect(mge, "PLASMID")) %>% filter(cog!="Not_assigned") %>% 
  group_by(status, sample, cog) %>% summarise(conteo_total=sum(conteo)) %>% ungroup()

plasmid_df <- cat_plasmid %>% 
  pivot_wider(names_from = cog, values_from = conteo_total, values_fill = 0) %>% select(-1) %>% as.data.frame() 
rownames(plasmid_df)<-plasmid_df[,1]
plasmid_df<-plasmid_df[,-1]

# Crear el dataframe metadata
metadata <- cat_plasmid %>%
  select(sample, status) %>% distinct() %>% 
  mutate(name=ifelse(status == "barcode30", "Baseline", 
      ifelse(status == "barcode32", "24 horas",
      ifelse(status=="barcode33", "10 días",status)))) %>% as.data.frame()
rownames(metadata)<-metadata[,1]
metadata<-metadata[,-1]

fit_data=Maaslin2(input_data = plasmid_df,
                  input_metadata = metadata,
                      output = "Maaslin2_plasmid_cog_none",       # Carpeta de salida para los resultados
                  fixed_effects = c("name"), 
                  reference = "name,Baseline",
                  min_prevalence = 0.2,
                  normalization="NONE",
                  transform = "NONE",
                  analysis_method = "NEGBIN")

#FILTRAR POR MENOR VALOR DE ´-VALUE DEL KRUSKAL WALLIS (data no es normal segun shapiro test)
k<-cat_plasmid %>% group_by(cog) %>% filter(n_distinct(status) >= 2) %>% summarise(k=kruskal.test(conteo_total ~ status)$p.value,                                                  wilcoxon_p=list(pairwise.wilcox.test(conteo_total,status, exact=FALSE, p.adjust.method="BH")$p.value))  %>% arrange(k) %>%
  slice_head(n = 9) %>%
  pull(cog)

test<-cat_plasmid %>% filter(cog=="C")
p<-pairwise.wilcox.test(test$conteo_total,test$status, exact=FALSE, p.adjust.method = "BH")

# Fltrar el dataframe para solo las 9 categorías de menor p value en Kruskal
filtered_cat_plasmid <- cat_plasmid %>%
  filter(cog %in% k)

# Crear los gráficos de boxplot
plots <- filtered_cat_plasmid %>%
  ggplot(aes(x = status, y = conteo_total, fill = status)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  facet_wrap(~ cog, scales = "free_y") +
  labs(title = "Boxplots por Status para las 9 Categorías de Mayor Mediana",
       x = "Status",
       y = "Conteo Total") +
  theme_minimal()+
    scale_x_discrete(labels = function(x) ifelse(x == "barcode30", "Baseline", 
                                               ifelse(x == "barcode32", "24 horas",
                                                      ifelse(x=="barcode33", "10 días",x))))
```
### COG PLÁSMIDOS CPM 
```{r}
cat_plasmid_cpm <- df_main  %>% filter(str_detect(mge, "PLASMID"))%>% filter(cog!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6) %>% 
  group_by(status, sample, cog) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
analysis_maaslin2_boxplot(input_data = cat_plasmid_cpm,"cog","plasmid",vector_recode =cog_categories)

```

### COG VIRUS CPM 
```{r}
cat_virus_cpm <- df_main  %>% filter(str_detect(mge, "VIRUS")) %>% filter(cog!="Not_assigned")%>% inner_join(libra, by="sample") %>% separate(mge, into = c("type_mge","length","rango"), sep=";",fill="right") %>% #ahora mantener los genes dentro de provirus
  mutate(
    in_range = case_when(
      str_detect(type_mge, "PROVIRUS") ~ if_else(!is.na(rango), {
                  rango_parts <- str_split(rango, "-", simplify = TRUE)
                  rango_start <- as.numeric(rango_parts[, 1])
                  rango_end <- as.numeric(rango_parts[, 2])
                  start >= rango_start & end <= rango_end
                }, FALSE,FALSE #else es falso
                ),TRUE ~ TRUE)
  ) %>%
  filter(in_range)%>%mutate(cpm=(conteo/size)*1e6) %>% 
  group_by(status, sample, cog) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
analysis_maaslin2_boxplot(input_data = cat_virus_cpm,"cog","virus", vector_recode = cog_categories)

```

### COG CHROMOSOMAL CONTIGS (NOT MGE)
```{r}
cat_main_cpm <- df_main  %>% filter(str_detect(mge, "NOT_MGE"))%>% filter(cog!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6) %>% 
  group_by(status, sample, cog) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
analysis_maaslin2_boxplot(input_data = cat_main_cpm,"cog","chromosome", vector_recode = cog_categories)

```

#GO MAASLIN2 AND BOXPLOTS 

###GO CONTEO CRUDO
```{r}
##GO
##PLASMIDO CONTEO CRUDO
cat_plasmid_go<-df_main %>% 
    filter(str_detect(mge, "PLASMID"),GO!="Not_assigned") %>% select(status,sample,GO, conteo)%>%separate_rows(GO, sep = ",")%>% 
  group_by(status, sample, GO) %>% summarise(conteo_total=sum(conteo)) %>% ungroup()  

plasmid_df <- cat_plasmid_go %>% 
  pivot_wider(names_from = GO, values_from = conteo_total, values_fill = 0) %>% select(-1) %>% as.data.frame()
rownames(plasmid_df)<-plasmid_df[,1]
plasmid_df<-plasmid_df[,-1]

# Crear el dataframe metadata
metadata <- cat_plasmid_go %>%
  select(sample, status) %>% distinct() %>% 
  mutate(name=ifelse(status == "barcode30", "Baseline", 
      ifelse(status == "barcode32", "24 horas",
      ifelse(status=="barcode33", "10 días",status)))) %>% as.data.frame()
rownames(metadata)<-metadata[,1]
metadata<-metadata[,-1]

fit_data=Maaslin2(input_data = plasmid_df,
                  input_metadata = metadata,
                      output = "Maaslin2_plasmid_GO",       # Carpeta de salida para los resultados
                  fixed_effects = c("name"), 
                  reference = "name,Baseline",
                  min_prevalence = 0.2,
                  normalization="TSS",
                  transform = "LOG",
                  analysis_method = "LM")

#FILTRAR POR MENOR VALOR DE ´-VALUE DEL KRUSKAL WALLIS (data no es normal segun shapiro test)
k<-cat_plasmid_go %>% group_by(GO) %>% filter(n_distinct(status) >= 2) %>% summarise(k=kruskal.test(conteo_total ~ status)$p.value,                                     wilcoxon_p=list(pairwise.wilcox.test(conteo_total,status, exact=FALSE, p.adjust.method="BH")$p.value))  %>% arrange(k) %>%
  slice_head(n = 9) %>%
  pull(GO)
##TEST INDIVIDUAL POR SEPARADO
test<-cat_plasmid_go %>% filter(GO=="GO:0017144")
p<-pairwise.wilcox.test(test$conteo_total,test$status, exact=FALSE, p.adjust.method = "BH")

# Fltrar el dataframe para solo las 9 categorías de menor p value en Kruskal
filtered_cat_plasmid <- cat_plasmid_go %>%
  filter(GO %in% k)

# Crear los gráficos de boxplot
plots <- filtered_cat_plasmid %>%
  ggplot(aes(x = status, y = conteo_total, fill = status)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  facet_wrap(~ GO, scales = "free_y") +
  labs(title = "Boxplots por Status para las 9 Categorías de Mayor Mediana",
       x = "Status",
       y = "Conteo Total") +
  theme_minimal()+
    scale_x_discrete(labels = function(x) ifelse(x == "barcode30", "Baseline", 
                                               ifelse(x == "barcode32", "24 horas",
                                                      ifelse(x=="barcode33", "10 días",x))))
```

### GO PLÁSMIDOS CPM 
```{r}
cat_plasmid_cpm <- df_main  %>% filter(str_detect(mge, "PLASMID")) %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,GO, cpm)%>%separate_rows(GO, sep = ",") %>% 
  group_by(status, sample, GO) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

  analysis_maaslin2_boxplot(cat_plasmid_cpm,"GO",origin =  "plasmid")
```

###GO VIRUS CPM 
```{r}
cat_virus_cpm <- df_main %>% filter(str_detect(mge, "VIRUS")) %>% inner_join(libra, by="sample") %>% separate(mge, into = c("type_mge","length","rango"), sep=";",fill="right") %>% #ahora mantener los genes dentro de provirus
  mutate(
    in_range = case_when(
      str_detect(type_mge, "PROVIRUS") ~ if_else(!is.na(rango), {
                  rango_parts <- str_split(rango, "-", simplify = TRUE)
                  rango_start <- as.numeric(rango_parts[, 1])
                  rango_end <- as.numeric(rango_parts[, 2])
                  start >= rango_start & end <= rango_end
                }, FALSE,FALSE #else es falso
                ),TRUE ~ TRUE)
  ) %>%
  filter(in_range)%>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,GO, cpm)%>%separate_rows(GO, sep = ",") %>% 
  group_by(status, sample, GO) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

analysis_maaslin2_boxplot(cat_virus_cpm,"GO","virus")


```

###GO Chromosomal contigs (NOT MGE)
```{r}
cat_main_cpm <- df_main  %>% filter(str_detect(mge, "NOT_MGE")) %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6)%>% select(status,sample,GO, cpm)%>%separate_rows(GO, sep = ",") %>% 
  group_by(status, sample, GO) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
analysis_maaslin2_boxplot(cat_main_cpm,"GO","chromosome",  slice_range = c(10, 18))

```

#KEGG MAASLIN2 AND BOXPLOTS 

###KEGG CONTEO CRUDO
```{r}
##PLASMIDO CONTEO CRUDO
cat_plasmid_pathways<-df_main %>% 
    filter(str_detect(mge, "PLASMID"),pathways!="Not_assigned") %>% select(status,sample,pathways, conteo)%>%separate_rows(pathways, sep = ",")%>% filter(str_detect(pathways,"map")) %>% 
  group_by(status, sample, pathways) %>% summarise(conteo_total=sum(conteo)) %>% ungroup()  

plasmid_df <- cat_plasmid_pathways %>% 
  pivot_wider(names_from = pathways, values_from = conteo_total, values_fill = 0) %>% select(-1) %>% as.data.frame()
rownames(plasmid_df)<-plasmid_df[,1]
plasmid_df<-plasmid_df[,-1]

# Crear el dataframe metadata
metadata <- cat_plasmid_pathways %>%
  select(sample, status) %>% distinct() %>% 
  mutate(name=ifelse(status == "barcode30", "Baseline", 
      ifelse(status == "barcode32", "24 horas",
      ifelse(status=="barcode33", "10 días",status)))) %>% as.data.frame()
rownames(metadata)<-metadata[,1]
metadata<-metadata[,-1]

fit_data=Maaslin2(input_data = plasmid_df,
                  input_metadata = metadata,
                      output = "Maaslin2_plasmid_pathways",       # Carpeta de salida para los resultados
                  fixed_effects = c("name"), 
                  reference = "name,Baseline",
                  min_prevalence = 0.2,
                  normalization="TSS",
                  transform = "LOG",
                  analysis_method = "LM")

#FILTRAR POR MENOR VALOR DE ´-VALUE DEL KRUSKAL WALLIS (data no es normal segun shapiro test)
k<-cat_plasmid_pathways %>% group_by(pathways) %>% filter(n_distinct(status) >= 2) %>% summarise(k=kruskal.test(conteo_total ~ status)$p.value,                                     wilcoxon_p=list(pairwise.wilcox.test(conteo_total,status, exact=FALSE, p.adjust.method="BH")$p.value))  %>% arrange(k) %>%
  slice_head(n = 9) %>%
  pull(pathways)

# Fltrar el dataframe para solo las 9 categorías de menor p value en Kruskal
filtered_cat_plasmid <- cat_plasmid_pathways %>%
  filter(pathways %in% k)

# Crear los gráficos de boxplot
plots <- filtered_cat_plasmid %>%
  ggplot(aes(x = status, y = conteo_total, fill = status)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  facet_wrap(~ pathways, scales = "free_y") +
  labs(title = "Boxplots por Status para las 9 Categorías de Mayor Mediana",
       x = "Status",
       y = "Conteo Total") +
  theme_minimal()+
    scale_x_discrete(labels = function(x) ifelse(x == "barcode30", "Baseline", 
                                               ifelse(x == "barcode32", "24 horas",
                                                      ifelse(x=="barcode33", "10 días",x))))
```

### KEGG PLÁSMIDOS CPM 
```{r}
cat_plasmid_cpm <- df_main  %>% filter(str_detect(mge, "PLASMID"),pathways!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,pathways, cpm)%>%separate_rows(pathways, sep = ",")%>% filter(str_detect(pathways,"map")) %>% 
  group_by(status, sample, pathways) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

analysis_maaslin2_boxplot(cat_plasmid_cpm,"pathways","plasmid")
```

###KEGG VIRUS CPM 
```{r}
cat_virus_cpm <- df_main %>% filter(str_detect(mge, "VIRUS"),pathways!="Not_assigned") %>% inner_join(libra, by="sample") %>% separate(mge, into = c("type_mge","length","rango"), sep=";",fill="right") %>% #ahora mantener los genes dentro de provirus
  mutate(
    in_range = case_when(
      str_detect(type_mge, "PROVIRUS") ~ if_else(!is.na(rango), {
                  rango_parts <- str_split(rango, "-", simplify = TRUE)
                  rango_start <- as.numeric(rango_parts[, 1])
                  rango_end <- as.numeric(rango_parts[, 2])
                  start >= rango_start & end <= rango_end
                }, FALSE,FALSE #else es falso
                ),TRUE ~ TRUE)
  ) %>%
  filter(in_range)%>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,pathways, cpm)%>%separate_rows(pathways, sep = ",")%>% filter(str_detect(pathways,"map")) %>% 
  group_by(status, sample, pathways) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

analysis_maaslin2_boxplot(cat_virus_cpm,"pathways","virus")


```

###KEGG Chromosomal contigs (NOT MGE)
```{r}
cat_main_cpm <- df_main  %>% filter(str_detect(mge, "NOT_MGE"),pathways!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6)%>% select(status,sample,pathways, cpm)%>%separate_rows(pathways, sep = ",") %>% filter(str_detect(pathways,"map"))%>% 
  group_by(status, sample, pathways) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
gt<-analysis_maaslin2_boxplot(cat_main_cpm,"pathways","chromosome")
```

#BRITE MAASLIN2 AND BOXPLOTS 
```{r}

##PLASMID
cat_plasmid_cpm <- df_main  %>% filter(str_detect(mge, "PLASMID"),brite!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,brite, cpm)%>%separate_rows(brite, sep = ",")%>% 
  group_by(status, sample, brite) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

g<-analysis_maaslin2_boxplot(cat_plasmid_cpm,"brite","plasmid")

###VIRUS
cat_virus_cpm <- df_main %>% filter(str_detect(mge, "VIRUS"),brite!="Not_assigned") %>% inner_join(libra, by="sample") %>% separate(mge, into = c("type_mge","length","rango"), sep=";",fill="right") %>% #ahora mantener los genes dentro de provirus
  mutate(
    in_range = case_when(
      str_detect(type_mge, "PROVIRUS") ~ if_else(!is.na(rango), {
                  rango_parts <- str_split(rango, "-", simplify = TRUE)
                  rango_start <- as.numeric(rango_parts[, 1])
                  rango_end <- as.numeric(rango_parts[, 2])
                  start >= rango_start & end <= rango_end
                }, FALSE,FALSE #else es falso
                ),TRUE ~ TRUE)
  ) %>%
  filter(in_range)%>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,brite, cpm)%>%separate_rows(brite, sep = ",")%>%
  group_by(status, sample, brite) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

analysis_maaslin2_boxplot(cat_virus_cpm,"brite","virus")
###CHROMOSOMAL CONTIGS
cat_main_cpm <- df_main  %>% filter(str_detect(mge, "NOT_MGE"),brite!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6)%>% select(status,sample,brite, cpm)%>%separate_rows(brite, sep = ",") %>% 
  group_by(status, sample, brite) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
analysis_maaslin2_boxplot(cat_main_cpm,"brite","chromosome")
g

```
#PFAM (identico a kegg_ko)
```{r}

##PLASMID
cat_plasmid_cpm <- df_main  %>% filter(str_detect(mge, "PLASMID"),pfams!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,pfams, cpm)%>%separate_rows(pfams, sep = ",")%>%  
  group_by(status, sample, pfams) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

analysis_maaslin2_boxplot(cat_plasmid_cpm,"pfams","plasmid")

###VIRUS
cat_virus_cpm <- df_main %>% filter(str_detect(mge, "VIRUS"),pfams!="Not_assigned") %>% inner_join(libra, by="sample") %>% separate(mge, into = c("type_mge","length","rango"), sep=";",fill="right") %>% #ahora mantener los genes dentro de provirus
  mutate(
    in_range = case_when(
      str_detect(type_mge, "PROVIRUS") ~ if_else(!is.na(rango), {
                  rango_parts <- str_split(rango, "-", simplify = TRUE)
                  rango_start <- as.numeric(rango_parts[, 1])
                  rango_end <- as.numeric(rango_parts[, 2])
                  start >= rango_start & end <= rango_end
                }, FALSE,FALSE #else es falso
                ),TRUE ~ TRUE)
  ) %>%
  filter(in_range)%>%mutate(cpm=(conteo/size)*1e6) %>% select(status,sample,pfams, cpm)%>%separate_rows(pfams, sep = ",")%>%
  group_by(status, sample, pfams) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()

analysis_maaslin2_boxplot(cat_virus_cpm,"pfams","virus")
###CHROMOSOMAL CONTIGS
cat_main_cpm <- df_main  %>% filter(str_detect(mge, "NOT_MGE"),pfams!="Not_assigned") %>% inner_join(libra, by="sample") %>%mutate(cpm=(conteo/size)*1e6)%>% select(status,sample,pfams, cpm)%>%separate_rows(pfams, sep = ",") %>% 
  group_by(status, sample, pfams) %>% summarise(conteo_total=sum(cpm)) %>%ungroup()
analysis_maaslin2_boxplot(cat_main_cpm,"pfams","chromosome")





```


##PARSING FROM API FUNCTIONS
```{r}
get_kegg_description <- function(code) {
  tryCatch({
    # Intentar obtener información de KEGG
    kegg_info <- keggGet(code)
    
    # Verificar si la respuesta contiene información válida
    if (length(kegg_info) > 0 && !is.null(kegg_info[[1]]$NAME)) {
      return(kegg_info[[1]]$NAME)
    } else {
      return("Not found")
    }
  }, error = function(e) {
    # Capturar errores, incluyendo el caso de código 404
    warning(paste("Error fetching KEGG information for code:", code, "-", e$message))
    return("Not found")
  })
}

##TEST
kegg_codes <- c("map00010", "map00020", "map00270")  # Reemplazar con tus códigos

# Obtener descripciones de los códigos KEGG
kegg_descriptions <- sapply(kegg_codes, get_kegg_description)

get_go_description_amigo <- function(go_term) {

# 1) Consultar la API con el término original
  base_url <- "http://api.geneontology.org/api/ontology/term/"
  query_url <- paste0(base_url, go_term)
  response <- GET(query_url)
  
  if (status_code(response) == 200) {
    content_json <- fromJSON(content(response, "text", encoding = "UTF-8"))
    if (!is.null(content_json$label) && nzchar(content_json$label)) {
      # Si encontramos un label válido, lo devolvemos
      return(content_json$label)
    }
  }
  
  # 2) No hubo éxito con la API o no había 'label'.
  #    Hacemos scraping en AmiGO para ver si hay un "replaced by".
  
  web_url <- paste0("https://amigo.geneontology.org/amigo/term/", go_term)
  page <- tryCatch(read_html(web_url), error = function(e) NULL)
  
  # Si no podemos acceder a la página o page es NULL, devolvemos "Not found".
  if (is.null(page)) {
    return("Not found")
  }
  replaced_by_term <- page %>%
    html_nodes(xpath = "//dd[strong[text()='replaced by']]") %>%
    html_node("a") %>%
    html_text(trim = TRUE)
  
  # Si no hay nada, devolvemos "Not found".
  if (is.na(replaced_by_term) || is.null(replaced_by_term) || replaced_by_term == "") {
    return("Not found")
  }
  
  # 3) Si encontramos un término de reemplazo, consultamos la API con ese nuevo término.
  new_query_url <- paste0(base_url, replaced_by_term)
  new_response <- GET(new_query_url)
  
  if (status_code(new_response) == 200) {
    new_content <- fromJSON(content(new_response, "text", encoding = "UTF-8"))
    if (!is.null(new_content$label) && nzchar(new_content$label)) {
      return(new_content$label)
    }
  }
  
  # 4) Si llegamos hasta aquí, no encontramos nada útil. Devolvemos "Not found".
  return("Not found")
}
##TEST
go_terms <- c("GO:0008150", "GO:0000004", "GO:0017144"

)

get_brite_description <- function(brite_code) {
  # Revisa si el código está entre los 'names()' del vector brite_data
  brite_data <- keggList("brite")
  if (brite_code %in% names(brite_data)) {
    return(brite_data[[brite_code]])
  } else {
    return(paste("El código", brite_code, "no se encontró en brite_data."))
  }
}
brite_codes <- c("br08303", "ko01000", "ko01004","ko03110" )  # Ejemplos

brite_descriptions <- sapply(as.character(brite_codes), get_brite_description)
brite_descriptions
kegg_descriptions

```
##RECODE FUNCTION
```{r}
recode_feature_names <- function(features, annotation_col, max_width = 300) {
  
  # Función interna para hacer saltos de línea
  wrap_text <- function(txt, width = 300) {
    paste(strwrap(txt, width = width), collapse = "\n")
  }
  
  recoded <- sapply(features, function(ft) {
    
    # Para 'cog' o 'pfam', devolvemos el feature sin cambios
    if (tolower(annotation_col) %in% c("cog", "pfams")) {
      return(ft)
    }
    
    # En caso contrario, intentamos recodificar
    if (tolower(annotation_col) == "pathways") {
      desc <- get_kegg_description(ft)
      print("IN KEGGGGGGGG IN THE RECODE FUNCTION")
      print(desc)
    } else if (tolower(annotation_col) == "brite") {
      desc <- get_brite_description(ft)
    } else if (tolower(annotation_col) == "go") {
      desc <- get_go_description_amigo(ft)  # Ejemplo
    } else {
      desc <- "No Description"
      print("NO DESCRIPTION INN RECODE FUNCTIONN")
    }
    
    # Ajusta la descripción si está vacía
    if (is.null(desc) || desc == "") desc <- "No Description"
    
    # Generar el string final
    out <- paste0(ft, ": ", desc)
    wrap_text(out, width = max_width)
    
  }, USE.NAMES = FALSE)
  
  # Retorna un named vector (nombres originales -> recodificados)
  names(recoded) <- features
  return(recoded)
}

```

###FUNCTION ANALYSYS II

```{r}
analysis_maaslin2_boxplot <- function(
  input_data,          # Data frame con columnas: sample, status, conteo_total y la de anotación
  annotation_col,      # Nombre de la columna: "GO", "KEGG", "BRITE", "PFAM", etc.
  origin = c("virus", "plasmid", "chromosome"),  # Para nombrar archivos y/o gráficos
  slice_range = c(1, 9), # Rango de filas a tomar tras ordenar por p-value (p.ej. c(1,9) o c(10,18))
  vector_recode = NULL # Named vector para recodificar las categorías
) {
  # --- Función interna para formatear el título de cada faceta --- #
  # Combina el "código" (ej. GO:XXXX) con la "descripción" y,
  # si excede 25 caracteres, inserta saltos de línea.
  wrap_title <- function(code, desc, max_width = 25) {
    if (is.null(desc) || desc == "") desc <- "No Description"
    # Agregar ": " entre el código y la descripción
    combined <- paste0(code, ": ", desc)
    # Ajustar con saltos de línea si excede max_width
    paste(strwrap(combined, width = max_width), collapse = "\n")
  }

  # Títulos para el "origen" (virus, plasmid, chromosome)
  origin_titles <- c(
    virus = "Virus",
    plasmid = "Plasmids",
    chromosome = "Chromosomal Contigs"
  )

  # Títulos para cada anotación
  annotation_titles <- c(
    cog = "Clusters of Orthologous Groups (COGs)",
    GO = "Gene Ontology (GO) Classes",
    pathways = "KEGG Pathways",
    brite = "BRITE Hierarchies",
    pfams = "PFAM Domains"
  )

  origin <- match.arg(origin)  # Validar argumento 'origin'
  annotation_col_sym <- rlang::sym(annotation_col)  # Convertir el nombre de la columna a símbolo

  # 1. pivot_wider para crear la matriz "cpm"
  df_cpm <- input_data %>%
    tidyr::pivot_wider(
      names_from  = !!annotation_col_sym,   # Columna con GO/KEGG/BRITE/PFAM
      values_from = conteo_total,
      values_fill = 0
    ) %>% 
    dplyr::select(-1) %>% 
    as.data.frame()

  # Asumimos que la primera columna es "sample" y la usamos como rownames
  rownames(df_cpm) <- df_cpm[, 1]
  df_cpm <- df_cpm[, -1]

  # 2. Crear la metadata
  metadata_df_cpm <- input_data %>%
    dplyr::select(sample, status) %>%
    dplyr::distinct() %>%
    dplyr::mutate(
      name = dplyr::case_when(
        status == "barcode30" ~ "Baseline",
        status == "barcode32" ~ "24 horas",
        status == "barcode33" ~ "10 días",
        TRUE                  ~ status
      )
    ) %>%
    as.data.frame()

  rownames(metadata_df_cpm) <- metadata_df_cpm[, 1]
  metadata_df_cpm <- metadata_df_cpm[, -1]

  # 3. Ejecutar Maaslin2 con carpeta de salida dinámica
  output_folder <- paste0("Maaslin2_", origin, "_", annotation_col, "_cpm")

  fit_data <- Maaslin2(
    input_data      = df_cpm,
    input_metadata  = metadata_df_cpm,
    output          = output_folder,
    fixed_effects   = c("name"),
    reference       = "name,Baseline",
    min_prevalence  = 0.2,
    normalization   = "TSS",
    transform       = "LOG",
    analysis_method = "LM"
  )

  # 4. Prueba de Kruskal-Wallis para cada categoría
  group_by_string <- annotation_col
  k_cpm <- input_data %>%
    dplyr::group_by(.data[[group_by_string]]) %>%
    dplyr::filter(dplyr::n_distinct(status) >= 2, dplyr::n_distinct(sample) >= 4) %>%
    dplyr::summarise(
      k          = stats::kruskal.test(conteo_total ~ status)$p.value,
      wilcoxon_p = list(
        pairwise.wilcox.test(
          conteo_total, status, 
          exact = FALSE,
          p.adjust.method = "BH"
        )$p.value
      )
    ) %>%
    dplyr::arrange(k)

  # 5. Seleccionar el subset de filas por rango
  start_slice <- slice_range[1]
  end_slice   <- slice_range[2]
  k_subset <- k_cpm %>%
    dplyr::slice(start_slice:end_slice)

  # 6. Unir al dataframe original
  filtered_cpm <- input_data %>%
    dplyr::filter(.data[[group_by_string]] %in% k_subset[[group_by_string]]) %>%
    dplyr::left_join(k_subset, by = group_by_string) %>%
    dplyr::mutate(
      !!group_by_string := factor(
        .data[[group_by_string]],
        levels = k_subset[[group_by_string]]
      )
    )

  # 7. Recodificación para los títulos de los boxplots
  #    Agregamos el código + descripción con salto de línea y
  #    para GO, forzamos la primera letra en mayúscula.
  if (tolower(annotation_col) == "go") {
    all_go_codes <- unique(filtered_cpm[[group_by_string]])
    
    go_wrapped <- sapply(all_go_codes, function(go_code) {
      desc <- get_go_description_amigo(go_code)
      # Primera letra en mayúscula
      if (!is.null(desc) && nzchar(desc)) {
        desc <- paste0(toupper(substr(desc, 1, 1)), substr(desc, 2,nchar(desc)))
      } else {
        desc <- "No Description"
      }
      wrap_title(go_code, desc, max_width = 25)
    })
    
    names(go_wrapped) <- all_go_codes
    
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!go_wrapped
        )
      )
    
  } else if (tolower(annotation_col) == "pathways") {
    all_kegg_codes <- unique(filtered_cpm[[group_by_string]])
    
    kegg_wrapped <- sapply(all_kegg_codes, function(kegg_code) {
      desc <- get_kegg_description(kegg_code)
      wrap_title(kegg_code, desc, max_width = 25)
    })
    names(kegg_wrapped) <- all_kegg_codes
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!kegg_wrapped
        )
      )
    
  } else if (tolower(annotation_col) == "cog" && !is.null(vector_recode)) {
    # Para COG se asume que 'vector_recode' ya contiene la recodificación
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!vector_recode
        )
      )
  }

  # 8. Crear el boxplot para este subset
  origin_title <- origin_titles[[origin]]
  annotation_title <- annotation_titles[[annotation_col]]
  combined_title <- paste0(annotation_title, " Abundance in ", origin_title)

  plot_box <- filtered_cpm %>%
    ggplot2::ggplot(aes(x = status, y = conteo_total, fill = status)) +
    ggplot2::geom_boxplot(outlier.shape = NA) +
    ggplot2::geom_jitter(width = 0.2, alpha = 0.5) +
    ggplot2::facet_wrap(
      stats::as.formula(paste0("~ ", group_by_string)),
      scales = "free_y"
    ) +
    ggplot2::geom_text(
      aes(label = paste("p =", round(k, 4))),
      x = Inf, y = Inf, hjust = 1.1, vjust = 1.1,
      size = 2.5, color = "black"
    ) +
    ggplot2::labs(
      title = combined_title, x = "Status", y = "CPM"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::scale_x_discrete(labels = function(x) dplyr::case_when(
      x == "barcode30" ~ "Baseline",
      x == "barcode32" ~ "24 horas",
      x == "barcode33" ~ "10 días",
      TRUE             ~ x
    )) +
    ggplot2::theme(
      plot.title       = ggplot2::element_text(size = 12, face = "bold", hjust = 0.5),
      axis.title.y     = ggplot2::element_text(size = 10),
      axis.text.x      = ggplot2::element_text(size = 9),
      axis.text.y      = ggplot2::element_text(size = 8),
      strip.text       = ggplot2::element_text(size = 7, color = "black"),
      panel.grid.major = ggplot2::element_line(color = "grey90", size = 0.5),
      panel.grid.minor = ggplot2::element_blank(),
      strip.background = ggplot2::element_blank(),
      strip.placement  = "outside"
    ) +
    ggplot2::guides(fill = "none")

  filename <- paste0(
    tolower(annotation_col), "_",
    tolower(origin), "_cpm_",
    start_slice, "-", end_slice, ".png"
  )

  ggplot2::ggsave(
    filename = filename,
    plot     = plot_box,
    width    = 8,
    height   = 6,
    dpi      = 300,
    bg       = "white"
  )

  # 9. Retornar todo lo necesario
  list(
    wide_data       = df_cpm,         # Matriz pivot resultante
    metadata        = metadata_df_cpm,
    maaslin_results = fit_data,       # Maaslin2
    kruskal_full    = k_cpm,          # Tabla completa con p-values
    kruskal_subset  = k_subset,       # Subset seleccionado
    filtered_data   = filtered_cpm,   # Data frame para el boxplot
    boxplot         = plot_box        # Objeto ggplot2
  )
}

```

###FUNCTION ANALYSIS III

```{r}
analysis_maaslin2_boxplot <- function(
  input_data,          # Data frame con columnas: sample, status, conteo_total y la de anotación
  annotation_col,      # Nombre de la columna: "GO", "KEGG", "BRITE", "PFAM", etc.
  origin = c("virus", "plasmid", "chromosome"),  # Para nombrar archivos y/o gráficos
  slice_range = c(1, 9), # Rango de filas a tomar tras ordenar por p-value (p.ej. c(1,9) o c(10,18))
  vector_recode = NULL # Named vector para recodificar las categorías (p.ej. para COG)
) {
  # --- Función interna para formatear el título de cada faceta --- #
  wrap_title <- function(code, desc, max_width = 25) {
    if (is.null(desc) || desc == "") desc <- "No Description"
    # Agregar ": " entre el código y la descripción
    combined <- paste0(code, ": ", desc)
    # Ajustar con saltos de línea si excede max_width
    paste(strwrap(combined, width = max_width), collapse = "\n")
  }
  # Títulos para el "origen" (virus, plasmid, chromosome)
  origin_titles <- c(
    virus     = "Virus",
    plasmid   = "Plasmids",
    chromosome = "Chromosomal Contigs"
  )

  # Títulos para cada anotación
  annotation_titles <- c(
    cog      = "Clusters of Orthologous Groups (COGs)",
    GO       = "Gene Ontology (GO) Classes",
    pathways = "KEGG Pathways",
    brite    = "BRITE Hierarchies",
    pfams    = "PFAM Domains"
  )

  origin <- match.arg(origin)  # Validar argumento 'origin'
  annotation_col_sym <- rlang::sym(annotation_col)  # Convertir el nombre de la columna a símbolo

  # 1. pivot_wider para crear la matriz "cpm"
  df_cpm <- input_data %>%
    tidyr::pivot_wider(
      names_from  = !!annotation_col_sym,   # Columna con GO/KEGG/BRITE/PFAM/COG
      values_from = conteo_total,
      values_fill = 0
    ) %>% 
        dplyr::select(-1) %>% 
    as.data.frame()

  # Asumimos que la primera columna es "sample" y la usamos como rownames
  rownames(df_cpm) <- df_cpm[, 1]
  df_cpm <- df_cpm[, -1]

  # 2. Crear la metadata
  metadata_df_cpm <- input_data %>%
    dplyr::select(sample, status) %>%
    dplyr::distinct() %>%
    dplyr::mutate(
      name = dplyr::case_when(
        status == "barcode30" ~ "Baseline",
        status == "barcode32" ~ "24 horas",
        status == "barcode33" ~ "10 días",
        TRUE                  ~ status
      )
    ) %>%
    as.data.frame()

  rownames(metadata_df_cpm) <- metadata_df_cpm[, 1]
  metadata_df_cpm <- metadata_df_cpm[, -1]

  # 3. Ejecutar Maaslin2 con carpeta de salida dinámica
  output_folder <- paste0("Maaslin2_", origin, "_", annotation_col, "_cpm_test5")

  fit_data <- Maaslin2(
    input_data      = df_cpm,
    input_metadata  = metadata_df_cpm,
    output          = output_folder,
    fixed_effects   = c("name"),
    reference       = "name,Baseline",
    min_prevalence  = 0.2,
    normalization   = "TSS",
    transform       = "LOG",
    analysis_method = "LM"
  )

  # 4. Prueba de Kruskal-Wallis para cada categoría
  group_by_string <- annotation_col
  
  expanded_data <- input_data %>%
  tidyr::pivot_wider(
    names_from  = !!annotation_col_sym,   # Columna con GO/KEGG/BRITE/PFAM/COG
    values_from = conteo_total,
    values_fill = 0
  ) %>%
  tidyr::pivot_longer(
    cols      = -c(sample, status),  # Mantener 'sample' y 'status', lo demás se vuelve "long"
    names_to  = annotation_col,      # Reutiliza la misma variable
    values_to = "conteo_total"
  )
  
k_cpm <- expanded_data %>%
  dplyr::group_by(.data[[annotation_col]]) %>%
  #dplyr::filter(dplyr::n_distinct(status) >= 2, dplyr::n_distinct(sample) >= 4) %>%
  dplyr::summarise(
    k          = stats::kruskal.test(conteo_total ~ status)$p.value,
    wilcoxon_p = list(
      pairwise.wilcox.test(
        conteo_total, status, 
        exact = FALSE,
        p.adjust.method = "BH"
      )$p.value
    )
  ) %>%
  dplyr::arrange(k)

  # 5. Seleccionar el subset de filas por rango
  start_slice <- slice_range[1]
  end_slice   <- slice_range[2]
  k_subset <- k_cpm %>%
    dplyr::slice(start_slice:end_slice)

  # 6. Unir al dataframe original con las p-values
filtered_cpm <- expanded_data %>%
  dplyr::filter(.data[[annotation_col]] %in% k_subset[[annotation_col]]) %>%
  dplyr::left_join(k_subset, by = annotation_col) %>%
  dplyr::mutate(
    # Ajustamos el orden de la faceta según k_subset
    !!annotation_col := factor(
      .data[[annotation_col]],
      levels = k_subset[[annotation_col]]
    )
  )

  # 7. Recodificación para los títulos de los boxplots
  if (tolower(annotation_col) == "go") {
    all_go_codes <- unique(filtered_cpm[[group_by_string]])
    
    go_wrapped <- sapply(all_go_codes, function(go_code) {
      desc <- get_go_description_amigo(go_code)
      # Primera letra en mayúscula
      if (!is.null(desc) && nzchar(desc)) {
        desc <- paste0(toupper(substr(desc, 1, 1)), substr(desc, 2,nchar(desc)))
      } else {
        desc <- "No Description"
      }
      wrap_title(go_code, desc, max_width = 25)
    })
    
    names(go_wrapped) <- all_go_codes
    
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!go_wrapped
        )
      )
    
  } else if (tolower(annotation_col) == "pathways") {
    all_kegg_codes <- unique(filtered_cpm[[group_by_string]])
    kegg_wrapped <- sapply(all_kegg_codes, function(kegg_code) {
      desc <- get_kegg_description(kegg_code)
      wrap_title(kegg_code, desc, max_width = 25)
    })
    names(kegg_wrapped) <- all_kegg_codes
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!kegg_wrapped
        ))
  } else if (tolower(annotation_col) == "brite") {
    all_brite_codes <- unique(filtered_cpm[[group_by_string]])
    brite_wrapped <- sapply(as.character(all_brite_codes), function(brite_code) {
      desc <- get_brite_description(brite_code)   # NUEVA FUNCIÓN
      wrap_title(brite_code, desc, max_width = 25)
    })
    gg<-brite_wrapped
    names(brite_wrapped) <- all_brite_codes
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!brite_wrapped
        )
      )

  } else if (tolower(annotation_col) == "cog" && !is.null(vector_recode)) {
    filtered_cpm <- filtered_cpm %>%
      dplyr::mutate(
        !!group_by_string := dplyr::recode(
          .data[[group_by_string]],
          !!!vector_recode
        )
      )
  }
  # PFAM -> No se hace recodificación

  # 8. Crear el boxplot para este subset
  origin_title <- origin_titles[[origin]]
  annotation_title <- annotation_titles[[annotation_col]]
  combined_title <- paste0(annotation_title, " Abundance in ", origin_title)

  # Para agregar asteriscos de KW, generamos columna con 'k_stars'
  plot_box <- filtered_cpm %>% 
  #     dplyr::group_by(!!rlang::sym(group_by_string),status) %>%
  # dplyr::filter(sd(conteo_total) > 0) %>% 
  # dplyr::ungroup()%>%
    ggplot2::ggplot(aes(x = status, y = conteo_total, fill = status)) +
    ggplot2::geom_boxplot(outlier.shape = NA) +
    ggplot2::geom_jitter(width = 0.2, alpha = 0.5) +
    ggplot2::facet_wrap(
      stats::as.formula(paste0("~ ", group_by_string)),
      scales = "free_y"
    ) +
    # Mostrar p-value de KW y estrellas en la esquina superior derecha +
    #    # ggplot2::geom_text(
    # 
    #   aes(label = paste("p =", round(k, 4))),
    # 
    #   x = Inf, y = Inf, hjust = 1.1, vjust = 1.1,
    # 
    #   size = 2.5, color = "black"
    # 
    # ) +
    ggplot2::labs(
      title = combined_title, x = "Status", y = "CPM"
    ) +
    ggplot2::theme_minimal() +
    ggplot2::scale_x_discrete(labels = function(x) dplyr::case_when(
      x == "barcode30" ~ "Baseline",
      x == "barcode32" ~ "24 horas",
      x == "barcode33" ~ "10 días",
      TRUE             ~ x
    )) +
    ggplot2::theme(
      plot.title       = ggplot2::element_text(size = 12, face = "bold", hjust = 0.5),
      axis.title.y     = ggplot2::element_text(size = 10),
      axis.text.x      = ggplot2::element_text(size = 9),
      axis.text.y      = ggplot2::element_text(size = 8),
      strip.text       = ggplot2::element_text(size = 7, color = "black"),
      panel.grid.major = ggplot2::element_line(color = "grey90", size = 0.5),
      panel.grid.minor = ggplot2::element_blank(),
      strip.background = ggplot2::element_blank(),
      strip.placement  = "outside"
    ) +
    ggplot2::guides(fill = "none")
  
  #  # 8.1. Agregamos estatísticas con ggpubr::stat_compare_means
  # # Definimos las comparaciones por pares para Wilcoxon.
  # # Ajustar según tus grupos reales en 'status'.
  comparisons_list <- list(
    c("barcode30", "barcode32"),  # Baseline vs 24h
    c("barcode30", "barcode33"),  # Baseline vs 10d
    c("barcode32", "barcode33")   # 24h vs 10d
  )

# (B) Agregar p-value Kruskal-Wallis (global)
plot_box <- plot_box +
  stat_compare_means(
    aes(group = status),
    method = "kruskal.test",
    label = "p.format",    # Muestra *** si p<0.001, etc. y ns si no
    hide.ns = TRUE,        # Oculta el "ns" y su bracket en caso de no significancia
    label.x.npc = "right",  # Ajusta posición en X
    label.y.npc = "top",   # Ajusta posición en Y
    size = 2.5,
    vjust = 1.2,
  )

# (C) Agregar comparaciones por pares (Wilcoxon)
plot_box<-plot_box +
  stat_compare_means(
    aes(group = status),
    method = "wilcox.test",
    p.adjust.method = "BH",
    comparisons = comparisons_list,
    label = "p.signif",    
    hide.ns = TRUE,        # OCULTA brackets y etiqueta si p>=0.05
    step.increase = 0.1,   # Espacio adicional entre brackets sucesivos
    bracket.size = 0.5,    
    tip.length = 0.02,     
    size = 4,              
    geom = "text",         # Texto con asteriscos
    vjust = 0.5
  )

  filename <- paste0(
    tolower(annotation_col), "_",
    tolower(origin), "_cpm_",
    start_slice, "-", end_slice, "test5.png"
  )

  ggplot2::ggsave(
    filename = filename,
    plot     = plot_box,
    width    = 8,
    height   = 6,
    dpi      = 300,
    bg       = "white"
  )
  print(head(expanded_data))

  res_sign <- fit_data$results %>%
  dplyr::filter(qval < 0.25)
  # --- CREACIÓN DE HEATMAPS ---
if (nrow(res_sign) == 0) {
  message("No significant features (qval < 0.25) found. Skipping heatmaps.")
} else {
  # ---------------------------
  # A) HEATMAP DE SIGNIFICANCIA (-log10(qval)*sign(coef))
  # ---------------------------
  res_sign <- res_sign %>%
    dplyr::mutate(
      qval_adj   = dplyr::if_else(qval == 0, 1e-300, qval),
      heat_value = -log10(qval_adj) * sign(coef)
    )
  heat_data <- res_sign %>%
    dplyr::select(feature, value, heat_value) %>%
    tidyr::pivot_wider(
      names_from  = value, 
      values_from = heat_value
    )
  
  heat_mat <- as.data.frame(heat_data[,-1])
  rownames(heat_mat) <- heat_data$feature
  print(heat_mat)
  # 2A. Recodificar (por si hay descripción KEGG, BRITE, GO, etc.)
       # "kegg", "brite", "go", etc.
  sig_features    <- rownames(heat_mat)  # features significativos
  recoded_vec     <-recode_feature_names(sig_features,group_by_string)
  print("ANTES")
  print(sig_features)
  print("DESPUES")
  print(recoded_vec)
  print("AÑADO A HEAT_MAT")
  rownames(heat_mat) <- recoded_vec
  print(heat_mat)
  class(heat_mat)
# 1. Abres el dispositivo (PNG, PDF, etc.)
heat_mat$feature <- rownames(heat_mat)
df_long <- heat_mat %>%
  pivot_longer(
    cols      = -feature,
    names_to  = "status",
    values_to = "value"
  )

p <- ggplot(df_long, aes(x = status, y = feature, fill = value)) +
  geom_tile(color = "black") +  # Borde negro en cada celda
  scale_fill_gradient2(
    midpoint = 0,   # Centra la escala en 0
    low = "blue", mid = "white", high = "red",
    name = "log2FC"
  ) +
  labs(
    title = "Heatmap of Log-Scaled Significance of Features with Baseline as Reference" ,
    x = "Condición",
    y = "Feature"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    # Centrar y dar formato al título
    plot.title = element_text(
      hjust  = 0.5,  # Centra el título horizontalmente
      face   = "bold",
      size   = 14
    ),
    # Ajustar el tamaño de las etiquetas del eje X (columnas) y eje Y (filas)
    axis.text.x = element_text(size = 12, angle = 45, vjust = 1, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title.x =element_text(size = 14),
    axis.title.y=element_text(size = 14),
    # Quitar las líneas de la cuadrícula
    panel.grid  = element_blank()
  ) +
  # Reducir el espacio vacío alrededor de las celdas
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  # Mantener la relación de aspecto fijo (hace que las celdas sean cuadradas).
  # Si lo quieres rectangular, ajusta 'ratio'
  coord_fixed()

# Ahora guardar con un tamaño más pequeño para que las celdas queden más chicas
ggsave(
  filename = paste0("heatmap_significance_", annotation_col, ".png"),
  plot     = p,
  width    = 8,   # Ajusta el ancho (en pulgadas si no se especifican units)
  height   = 6,   # Ajusta el alto
  dpi      = 300,
  bg       = "white"
)
  
  # ---------------------------
  # B) HEATMAP DE LOG2(ABUNDANCIA)
  # ---------------------------
  # # 3A. Filtrar 'expanded_data' sólo con esos features significativos
expanded_filt <- gt$expanded_data %>%
  dplyr::filter(!!annotation_col_sym%in% sig_features) %>%
  mutate(name=ifelse(status == "barcode30", "Baseline", 
                     ifelse(status == "barcode32", "24 horas",
                            ifelse(status=="barcode33", "10 días",status)))) %>% 
  dplyr::filter(name%in% c(res_sign$value,"Baseline"))  %>% group_by(!!annotation_col_sym,name) %>%
  summarize(mean_value=mean(conteo_total)) %>% 
  pivot_wider(names_from=name,values_from = mean_value) %>%  ungroup() %>% 
  mutate(across(-c(!!annotation_col_sym,Baseline),~ log2( (.x + 1) / (Baseline + 1) ), .names = "{.col}")) 
  old_feats_2      = unique(expanded_filt %>% dplyr::pull(!!annotation_col_sym))
  print(expanded_filt)
  print("ANTES")
  print(old_feats_2)
  recoded_vec_2 <- recode_feature_names(old_feats_2,group_by_string)
  # 
  print("LUEGO")
  print(recoded_vec_2)
  expanded_filt <- expanded_filt %>%
    dplyr::mutate(
      !!group_by_string := dplyr::recode(
        .data[[group_by_string]],
        !!!recoded_vec_2
      )
    )
  expanded_filt<-expanded_filt %>%
  column_to_rownames(var = rlang::as_string(annotation_col_sym)) %>% select(-Baseline)
  print(head(expanded_filt))
expanded_filt$feature <- rownames(expanded_filt)
df_long <- expanded_filt %>%
  pivot_longer(
    cols      = -feature,
    names_to  = "status",
    values_to = "value"
  )

p <- ggplot(df_long, aes(x = status, y = feature, fill = value)) +
  geom_tile(color = "black") +  # Borde negro en cada celda
  scale_fill_gradient2(
    midpoint = 0,   # Centra la escala en 0
    low = "blue", mid = "white", high = "red",
    name = "log2FC"
  ) +
  labs(
    title = "Heatmap of log2(Abundance) of Features (Qval < 0.25) with Baseline as Reference",
    x = "Condición",
    y = "Feature"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    # Centrar y dar formato al título
    plot.title = element_text(
      hjust  = 0.5,  # Centra el título horizontalmente
      face   = "bold",
      size   = 14
    ),
    # Ajustar el tamaño de las etiquetas del eje X (columnas) y eje Y (filas)
    axis.text.x = element_text(size = 12, angle = 45, vjust = 1, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title.x =element_text(size = 14),
    axis.title.y=element_text(size = 14),
    # Quitar las líneas de la cuadrícula
    panel.grid  = element_blank()
  ) +
  # Reducir el espacio vacío alrededor de las celdas
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  # Mantener la relación de aspecto fijo (hace que las celdas sean cuadradas).
  # Si lo quieres rectangular, ajusta 'ratio'
  coord_fixed()

# Ahora guardar con un tamaño más pequeño para que las celdas queden más chicas
ggsave(
  filename = paste0("heatmap_log2abundance_", annotation_col, ".png"),
  plot     = p,
  width    = 8,   # Ajusta el ancho (en pulgadas si no se especifican units)
  height   = 6,   # Ajusta el alto
  dpi      = 300,
  bg       = "white"
)




  
}
  # 9. Retornar todo lo necesario
  list(
    wide_data       = df_cpm,         # Matriz pivot resultante
    metadata        = metadata_df_cpm,
    maaslin_results = fit_data,       # Maaslin2
    kruskal_full    = k_cpm,          # Tabla completa con p-values
    kruskal_subset  = k_subset,       # Subset seleccionado
    filtered_data   = filtered_cpm,   # Data frame para el boxplot
    boxplot         = plot_box,        # Objeto ggplot2
  #log2_mat=log2_mat,
  heat_mat=heat_mat,
  expanded_data=expanded_data,
  expanded_filt=expanded_filt
    )  
}

```






